<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TP3_INFO804 GALERNE</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/basic.css">
  </head>
  <body>
    <div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> TP3_INFO804 GALERNE</div>
    <canvas id="webglcanvas" style="border: none;background-color:#000000"
	    width="800" height="600"></canvas>
    
    <script type="importmap">
      {
	  "imports": {
	      "three": "./three.module.js",
	      "three/addons/controls/": "./examples/jsm/controls/"
	  }
      }
    </script>

	<!-- Shaders -->
	<!-- <script id="post-vert" type="x-shader/x-vertex">
		// Vertex shader
		uniform float moment; // (général) temps écoulé depuis le début
		uniform float scale;  // (général) paramètre donnant le gonflement périodique
		out vec3 fn;          // (sortie) normale au sommet (repère écran)
		out vec3 vertPos;     // (sortie) coordonnées 3D du sommet (repère écran)
		out vec3 gblPos;      // (sortie) coordonnées 3D du sommet (repère général)
		void main() {
			float t = mod( moment, 6.28318530717958647688 );
			// On gonfle légèrement le soleil périodiquement en fonction du temps.
			vec3 scaled_pos = position + scale * (1.0+cos( 2.0*t)) * normal;
			gblPos          = scaled_pos;
			// On calcule le vecteur normal au sommet dans le repère écran      
			fn              = vec3( normalMatrix * normal );
			// On calcule la position du sommet dans le repère caméra
			vec4 vertPos4   = modelViewMatrix * vec4( scaled_pos, 1.0 );
			// On envoie au fragment shader la position du sommet dans
			// le repère camera.
			vertPos         = vec3(vertPos4) / vertPos4.w;
			// On indique à OpenGL la position du sommet dans le repère écran/pixel
			gl_Position     = projectionMatrix * vertPos4;
		}
	</script>

	<script id="post-frag" type="x-shader/x-fragment">
		// Fragment/pixel shader
		in vec3 fn;      // (entrée) normale du pixel (repère écran) (interpolée)
		in vec3 vertPos; // (entrée) coordonnées 3D du pixel (repère écran)(interpolées)
		in vec3 gblPos;  // (entrée) coordonnées 3D du pixel (repère général)(interpolées)
		uniform float moment; // (général) temps écoulé depuis le début
		out vec4 outColor; // (sortie) la couleur de sortie du pixel
		
		void main() {
			float t = mod( moment, 6.28318530717958647688 ); // temps
			vec3 n1 = normalize(fn); // vecteur normal au soleil (repère écran)
			float l = abs( n1.z );   // proche de 0 sur les bords du soleil
			outColor.rgb = vec3( 1.0 , 0.6+0.4* cos( 4.*gblPos.x + 3.*t ), l );
			outColor.a   = 1.0;
		}
	</script> -->

	<script id="post-vert" type="x-shader/x-vertex">
        // Simple vertex shader
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }


    </script>
    
        
    <script id="post-frag" type="x-shader/x-fragment">
      // Simple fragment shader for a solid color
      precision mediump float;
      
      uniform vec4 color; // Color uniform that will be set to the desired color
      
      void main() {
          gl_FragColor = vec4( 0.0, 0.0, 1.0, 1.0 ); // color;
      }
  	</script>
	
	<!-- Scène -->
    <script type="module">
      import * as THREE from 'three';
	  import { OrbitControls} from 'three/addons/controls/OrbitControls.js';
      
      var renderer = null; 
      var scene    = null;
      var camera   = null;
	  var controls = null;
	  var cameraAngle = 0;
	  var earth    = null;
	  var moon     = null;
	  var sun      = null;
      var curTime  = Date.now();
      var canvas = document.getElementById("webglcanvas");

	  var earthGroup = new THREE.Group();
	  var moonGroup  = new THREE.Group();
	  var earthSystem= new THREE.Group(); // terre et lune
	  
	  var sunGroup  = new THREE.Group();
	  var sunSystem = new THREE.Group();

	  var shader;
	  var uniforms;

      // Checks that your browser supports WebGL. 
      if ( ! ( window.WebGLRenderingContext
	       && ( canvas.getContext('webgl')
		    || canvas.getContext('experimental-webgl')) ) )
	  console.log( "WebGL not supported on your browser." );
      
      init();
      run();
      
      // This function is called whenever the document is loaded
      function init() {
	  
		// Create the Three.js renderer and attach it to our canvas
		renderer = new THREE.WebGLRenderer( { canvas: canvas,
							antialias: true } );
		// Set the viewport size
		//renderer.setSize( canvas.width, canvas.height );
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		// rendu coûteux mais plus joli (default: THREE.PCFShadowMap)
		renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
		// Create a new Three.js scene
		scene = new THREE.Scene();
		// Add  a camera so we can view the scene
		camera = new THREE.PerspectiveCamera( 45, /*canvas.width / canvas.height*/ window.innerWidth / window.innerHeight,
							1, 4000 );

		// Arrière-plan
		var path = "./images/skybox/";
		var format = '.jpg';
		var urls = [
			path + 'posx' + format, path + 'negx' + format,
			path + 'posy' + format, path + 'negy' + format,
			path + 'posz' + format, path + 'negz' + format
		];
		
		var textureCube    = new THREE.CubeTextureLoader().load( urls );
		textureCube.type   = THREE.UnsignedByteType;
		textureCube.format = THREE.RGBAFormat;
		scene.background   = textureCube;

		// TERRE
		// Create a texture-mapped sphere and add it to the scene
		// First, create the texture map
		var mapUrl = "./images/earth_atmos_2048.jpg";
		var map    = new THREE.TextureLoader().load( mapUrl );
		// Now, create a Phong material; pass in the map
		var material = new THREE.MeshPhongMaterial({ 
			map: map, 
			specular: new THREE.Color("white"), 
			emissive: 0x009cdf, 
			emissiveIntensity: 0.1, 
			normalMap: new THREE.TextureLoader().load( "./images/earth_normal_2048.jpg" ),
			lightMap: new THREE.TextureLoader().load( "./images/earth_lights_2048.png" ),
			specularMap: new THREE.TextureLoader().load( "./images/earth_specular_2048.jpg" )
		});
		// Create the sphere geometry
		var geometry = new THREE.SphereGeometry();//THREE.BoxGeometry(2, 2, 2);
		// And put the geometry and material together into a mesh
		earth = new THREE.Mesh(geometry, material);
		// Move the mesh back from the camera and tilt it toward the viewer
		earth.position.z = -12;
		earth.position.x = -5;
		earth.rotation.x = Math.PI / 5;
		earth.rotation.y = Math.PI / 5;	
		earthSystem.add( earth );
		earthGroup.add( earthSystem );
		//earthSystem.position.x = earthGroup.position.x + 5;
		// scene.add( earthGroup );

		// LUNE
		var moonMapUrl = "./images/moon_1024.jpg";
		var moonMap = new THREE.TextureLoader().load( moonMapUrl );
		var moonMaterial = new THREE.MeshPhongMaterial({ map: moonMap, specular: new THREE.Color("gray") });
		var moonGeometry = new THREE.SphereGeometry(0.5);
		moon = new THREE.Mesh(moonGeometry, moonMaterial);
		moon.position.z = -14;
		moon.position.x = -4;
		moon.position.y = 1.5;
		moon.rotation.x = Math.PI / 5;
		moon.rotation.y = Math.PI / 5;	
		moonGroup.add( moon )
		earthGroup.add( moonGroup )
		//scene.add( moonGroup );

		// SOLEIL
		// Add a white point light, which lights at infinite distance and without decay
		// with the distance.
		var sunGeometry = new THREE.SphereGeometry(1.6);
		var sunMaterial = new THREE.MeshBasicMaterial({ 
			map: new THREE.TextureLoader().load( "./images/sun_texture.jpg" ),
			color: new THREE.Color("yellow"),
		});
		sun = new THREE.Mesh(sunGeometry, sunMaterial);
		sun.position.z = -10;
		// sun.position.y = 1;
		// sun.position.x = 5;
		sunGroup.add( sun );
		// scene.add( sun );

		var light = new THREE.PointLight( 0xffffff, 2.5, 0.0, 0.0 );
		light.position.set( 0, 0, -10 );
		light.castShadow = true;
		// On peut aussi paramétrer la qualité du calcul
		light.shadow.mapSize.width  = 512; // default
		light.shadow.mapSize.height = 512; // default
		light.shadow.camera.near    = 0.5; // default
		light.shadow.camera.far     = 50;
		sunGroup.add( light );
		// scene.add( light );

		// ajout des groupes
		sunGroup.add( earthGroup );
		sunSystem.add( sunGroup );
		//sunSystem.add( earthGroup );

		// Gestion des ombres
		sun.castShadow      = false;
		sun.receiveShadow   = false;
		earth.castShadow    = true;
		earth.receiveShadow = true;
		moon.castShadow     = true;
		moon.receiveShadow  = true;

		// Shaders
		// uniforms = {
        //   moment: { value: 0.0 },
        //   scale:  { value: 0.02 }
		// };
		// shader = new THREE.ShaderMaterial( {
		// 	vertexShader: document.querySelector( '#post-vert' ).textContent.trim(),
		// 	fragmentShader: document.querySelector( '#post-frag' ).textContent.trim(),
		// 	uniforms: uniforms
		// } );
		// shader.glslVersion = THREE.GLSL1;
		// // On réutilise la géométrie de sphère de rayon 1.
		// var sunHalo  = new THREE.Mesh( geometry, shader );
		//shaders material management
		uniforms = {
            color: { value: new THREE.Color(0xff0000) }
		};
		shader = new THREE.ShaderMaterial( {
			vertexShader: document.querySelector( '#post-vert' ).textContent.trim(),
			fragmentShader: document.querySelector( '#post-frag' ).textContent.trim(),
			uniforms: uniforms
		} );
		shader.glslVersion = THREE.GLSL2;
		// On réutilise la géométrie de sphère de rayon 1.
		var sunHalo  = new THREE.Mesh( geometry, shader );
		sunHalo.castShadow = false;
		sunHalo.receiveShadow = false;
		sunGroup.add( sunHalo );

		// ajout du système solaire à la scène
		scene.add( sunSystem );

		// Contrôle de la caméra
		controls = new OrbitControls( camera, renderer.domElement );
		controls.target = earth.position;
		// controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
		controls.enableDamping      = true; // an animation loop is required when either damping or auto-rotation are enabled
		controls.dampingFactor      = 0.25;
		controls.screenSpacePanning = false;
		controls.minDistance        = 1;
		controls.maxDistance        = 100;
		controls.maxPolarAngle      = Math.PI / 2;
		controls.update();
      }
      
      // This function is called regularly to update the canvas webgl.
      function run() {
		// Ask to call again run 
		requestAnimationFrame( run );
		
		// Render the scene
		render();
		
		// Calls the animate function if objects or camera should move
		animate();
      }
      
      // This function is called regularly to take care of the rendering.
      function render() {
		// Render the scene
		renderer.render( scene, camera );
      }
      
      // This function is called regularly to update objects.
      function animate() {
		controls.update();
		// Computes how time has changed since last display
		var now       = Date.now();
		var deltaTime = now - curTime;
		curTime       = now;
		var fracTime  = deltaTime / 1000; // in seconds
		// Now we can move objects, camera, etc.

		var angle = fracTime * Math.PI * 2;
		// Notez que l'axe y est l'axe "vertical" usuellement.
		earthGroup.rotation.y += angle / 365; // la terre tourne en 365 jours
		earth.rotation.y      += angle; // et en un jour sur elle-même
		moonGroup.rotation.y  += angle / 28; // la lune tourne en 28 jours autour de la terre
		moon.rotation.y       += angle /28; // et en 28 jours aussi sur elle-même pour faire face à la terre

		// On change le `moment` pour le shader.
		//shader.uniforms.moment.value += fracTime;

		// caméra
		// camera.lookAt( earth.matrixWorld.getPosition() );
		// Avec un grand demi-axe de 5 et un petit demi-axe de 3
		// camera.position.x = 5 * Math.cos( cameraAngle );
		// camera.position.y = 3 * Math.sin( cameraAngle );
      }
      
    </script>

  </body>
</html>

